---
description: Tổng quan về ES6
image: https://4.bp.blogspot.com/-oK1U8Mxh0do/VwKkWfHuhzI/AAAAAAAAS2M/nCj-Zc2r7XUmhdjn95pbhyjQ6ISXHYfww/s640/ecmascript6.png
toc_max_heading_level: 6
sidebar_position: 1
---

import { Callout } from "nextra/components";

# ES6

ES6 (ECMAScript 2015) là một phiên bản của ngôn ngữ lập trình JavaScript, được phát hành vào tháng 6 năm 2015. ES6 mang đến nhiều tính năng mới và cải tiến cho JavaScript, giúp lập trình viên viết mã dễ dàng hơn và hiệu quả hơn.
Nó đã trở thành một tiêu chuẩn quan trọng trong phát triển web và được hỗ trợ bởi hầu hết các trình duyệt hiện đại.

## Tính năng mới trong ES6

Dưới đây là một số tính năng nổi bật của ES6:

### Khai báo biến với `let` và `const`

Trước ES6, JavaScript chỉ hỗ trợ khai báo biến với từ khóa `var`. Với ES6, bạn có thể sử dụng `let` để khai báo biến có phạm vi khối (block scope) và `const` để khai báo biến không thể thay đổi giá trị (constant).

```javascript
let x = 10;
const y = 20;
x = 15; // Hợp lệ
y = 25; // Lỗi: không thể thay đổi giá trị của biến hằng
```

- `let`: Khai báo biến có phạm vi khối (block scope).
    
    > `block scope` là phạm vi mà biến chỉ có thể được truy cập trong một khối mã cụ thể, chẳng hạn như trong một hàm hoặc trong một khối điều kiện hoặc trong 1 cặp dấu ngoặc nhọn `{}`.

    ```javascript
    if (true) {
        let x = 10;
        console.log(x); // In ra 10
    }
    console.log(x); // Lỗi: x không được định nghĩa
    ```

- `const`: Khai báo biến không thể thay đổi giá trị (constant).
    
    > Biến được khai báo bằng `const` không thể được gán lại giá trị mới sau khi đã được khởi tạo. Tuy nhiên, nếu biến là một đối tượng hoặc mảng, bạn vẫn có thể thay đổi các thuộc tính hoặc phần tử bên trong nó.

    ```javascript
    const PI = 3.14;
    console.log(PI); // In ra 3.14

    PI = 3.14159; // Lỗi: không thể thay đổi giá trị của biến hằng
    ```

    ```javascript
    const arr = [1, 2, 3];
    arr.push(4); // Hợp lệ: thêm phần tử vào mảng
    console.log(arr); // In ra [1, 2, 3, 4]
    arr = [5, 6, 7]; // Lỗi: không thể thay đổi giá trị của biến hằng
    ```

Lợi ích chính:

- Giúp tránh xung đột tên biến trong phạm vi toàn cục (global scope).
- Giúp dễ dàng quản lý và bảo trì mã nguồn.

### Arrow Functions

Arrow functions là một cách viết hàm ngắn gọn hơn trong ES6. Chúng giúp giảm bớt cú pháp và làm cho mã dễ đọc hơn.

**Cú pháp:**

```javascript
const functionName = (parameters) => {
    // Thân hàm
};
```

**Ví dụ:**

```javascript
const add = (a, b) => a + b;
console.log(add(2, 3)); // In ra 5
```
```javascript
const square = x => x * x; // Nếu chỉ có một tham số, có thể bỏ qua dấu ngoặc đơn
console.log(square(5)); // In ra 25
```
```javascript
const greet = (name) => {
    return `Hello, ${name}!`;
};
console.log(greet('John')); // In ra Hello, John!
```

Lợi ích chính:
- Giúp viết hàm ngắn gọn hơn.
- Tự động ràng buộc `this` trong hàm, giúp tránh các vấn đề liên quan đến ngữ cảnh (context) khi sử dụng hàm.
    ```javascript
    const obj = {
        name: 'John',
        greet: function() {
            setTimeout(() => {
                // Sử dụng arrow function để giữ context của `this`
                console.log(`Hello, ${this.name}!`);
            }, 1000);
        }
    };
    obj.greet(); // In ra Hello, John! sau 1 giây
    ```

### Template Literals

Template literals là một cách viết chuỗi mới trong ES6, cho phép bạn nhúng biểu thức (interpolation) và sử dụng nhiều dòng mà không cần phải sử dụng dấu `+` để nối chuỗi.

**Cú pháp:**

```javascript
const variableName = `Chuỗi ${biểu_thức}`;
```
**Ví dụ:**

```javascript
const name = 'John';
const age = 30;
const message = `Hello, my name is ${name} and I am ${age} years old.`;
console.log(message); // In ra Hello, my name is John and I am 30 years old.
```
```javascript
const multiLineString = `Đây là một chuỗi
nhiều dòng
và không cần sử dụng dấu \n`;
console.log(multiLineString);
// In ra:
// Đây là một chuỗi
// nhiều dòng
// và không cần sử dụng dấu \n
```

Lợi ích chính:
- Giúp viết chuỗi dễ dàng hơn và dễ đọc hơn.
- Hỗ trợ nhúng biểu thức và nhiều dòng mà không cần sử dụng dấu `+` để nối chuỗi.

### Default Parameters

Default parameters cho phép bạn định nghĩa giá trị mặc định cho các tham số của hàm. Nếu không truyền giá trị cho tham số đó khi gọi hàm, giá trị mặc định sẽ được sử dụng.

**Cú pháp:**

```javascript
function functionName(parameter1 = defaultValue1, parameter2 = defaultValue2) {
    // Thân hàm
}
```

**Ví dụ:**

```javascript
function greet(name = 'Guest') {
    console.log(`Hello, ${name}!`);
}
greet(); // In ra Hello, Guest!
greet('John'); // In ra Hello, John!
```
```javascript
function add(a, b = 0) {
    return a + b;
}
console.log(add(5)); // In ra 5
console.log(add(5, 10)); // In ra 15
```

Lợi ích chính:
- Giúp giảm bớt mã lặp lại khi bạn cần kiểm tra xem tham số có được truyền hay không.
- Giúp dễ dàng định nghĩa giá trị mặc định cho các tham số của hàm.

### Destructuring Assignment

Destructuring assignment là một cú pháp mới trong ES6 cho phép bạn trích xuất giá trị từ mảng hoặc đối tượng và gán chúng vào các biến riêng biệt.

**Cú pháp:**

```javascript
const [variable1, variable2] = array;
const { property1, property2 } = object;
```

**Ví dụ:**

```javascript
const arr = [1, 2, 3];
const [a, b] = arr;
console.log(a); // In ra 1
console.log(b); // In ra 2
```
```javascript
const obj = { x: 10, y: 20 };
const { x, y } = obj;
console.log(x); // In ra 10
console.log(y); // In ra 20
```
```javascript
const person = { name: 'John', age: 30 };
const { name, age } = person;
console.log(name); // In ra John
console.log(age); // In ra 30
```

Lợi ích chính:
- Giúp viết mã ngắn gọn hơn và dễ đọc hơn.
- Giúp dễ dàng trích xuất giá trị từ mảng hoặc đối tượng mà không cần phải sử dụng cú pháp truyền thống.
- Giúp giảm bớt mã lặp lại khi bạn cần truy cập nhiều thuộc tính của một đối tượng hoặc nhiều phần tử của một mảng.

    ```javascript
    const person = { name: 'John', age: 30, address: { city: 'New York', country: 'USA' } };
    const { name, age, address: { city } } = person;
    console.log(name); // In ra John
    console.log(age); // In ra 30
    console.log(city); // In ra New York
    ```

### Rest and Spread Operators

Rest và spread operators là hai cú pháp mới trong ES6 giúp bạn làm việc với mảng và đối tượng một cách dễ dàng hơn.
- **Rest operator** (`...`) cho phép bạn thu thập các phần tử còn lại của một mảng hoặc đối tượng thành một mảng hoặc đối tượng mới.
- **Spread operator** (`...`) cho phép bạn phân tách các phần tử của một mảng hoặc đối tượng thành các phần tử riêng biệt.

**Cú pháp:**

```javascript
const newArray = [...array1, ...array2];
const newObject = { ...object1, ...object2 };
```
```javascript
function functionName(...restParameters) {
    // Thân hàm
}
```

**Ví dụ:**

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combinedArray = [...arr1, ...arr2];
console.log(combinedArray); // In ra [1, 2, 3, 4, 5, 6]
```
```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const combinedObject = { ...obj1, ...obj2 };
console.log(combinedObject); // In ra { a: 1, b: 2, c: 3, d: 4 }
```
```javascript
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}
console.log(sum(1, 2, 3, 4)); // In ra 10
```
```javascript
function multiply(multiplier, ...numbers) {
    return numbers.map(num => num * multiplier);
}
console.log(multiply(2, 1, 2, 3)); // In ra [2, 4, 6]
```

Lợi ích chính:
- Giúp viết mã ngắn gọn hơn và dễ đọc hơn.
- Giúp dễ dàng làm việc với mảng và đối tượng mà không cần phải sử dụng các phương thức truyền thống như `concat`, `push`, `apply`, v.v.
- Giúp dễ dàng truyền nhiều tham số vào hàm mà không cần phải định nghĩa rõ ràng số lượng tham số.
- Giúp dễ dàng sao chép và kết hợp các mảng hoặc đối tượng mà không cần phải sử dụng vòng lặp hoặc các phương thức phức tạp.
- Giúp dễ dàng làm việc với các tham số không xác định trong hàm mà không cần phải sử dụng các phương thức truyền thống như `arguments`.

### Classes

ES6 giới thiệu cú pháp lớp (class) mới, giúp bạn định nghĩa các lớp và kế thừa một cách dễ dàng hơn. Cú pháp lớp trong ES6 tương tự như trong các ngôn ngữ lập trình hướng đối tượng khác như Java hoặc C#.

**Cú pháp:**

```javascript
class ClassName {
    constructor(parameters) {
        // Khởi tạo đối tượng
    }

    methodName() {
        // Phương thức của lớp
    }
}
```
```javascript
class SubClassName extends SuperClassName {
    constructor(parameters) {
        super(parameters); // Gọi hàm khởi tạo của lớp cha
        // Khởi tạo đối tượng
    }

    methodName() {
        // Phương thức của lớp con
    }
}
```

**Ví dụ:**

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
    }
}
const john = new Person('John', 30);
john.greet(); // In ra Hello, my name is John and I am 30 years old.
```
```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} makes a noise.`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks.`);
    }
}
const dog = new Dog('Rex');
dog.speak(); // In ra Rex barks.
```

Lợi ích chính:
- Giúp viết mã dễ đọc hơn và dễ bảo trì hơn.
- Giúp dễ dàng định nghĩa các lớp và kế thừa mà không cần phải sử dụng cú pháp phức tạp như trong ES5.
- Giúp dễ dàng tạo ra các đối tượng và phương thức mà không cần phải sử dụng hàm khởi tạo (constructor function) như trong ES5.
- Giúp dễ dàng sử dụng các tính năng của lập trình hướng đối tượng như kế thừa, đóng gói và trừu tượng hóa.

### Modules (Import/Export)

ES6 giới thiệu cú pháp module mới, cho phép bạn chia mã thành các tệp riêng biệt và sử dụng lại chúng trong các tệp khác. Điều này giúp tổ chức mã tốt hơn và dễ dàng quản lý hơn.

**Cú pháp:**

```javascript /export/
// Export một biến hoặc hàm
export const variableName = value;
export function functionName(parameters) {
    // Thân hàm
}

// Export một đối tượng
export default {
    property1: value1,
    property2: value2
};

// Export một lớp
export class ClassName {
    constructor(parameters) {
        // Khởi tạo đối tượng
    }

    methodName() {
        // Phương thức của lớp
    }
}
```
```javascript /import/
// Import một biến hoặc hàm
import { variableName, functionName } from './module.js';

// Import một đối tượng
import defaultExport from './module.js';

// Import một lớp
import { ClassName } from './module.js';
```

**Ví dụ:**

```javascript filename="module.js" /export/
export const PI = 3.14;
export function add(a, b) {
    return a + b;
}
```
```javascript filename="main.js" /import/
import { PI, add } from './module.js';

console.log(PI); // In ra 3.14
console.log(add(2, 3)); // In ra 5
```

Import/Export mặc định:

```javascript filename="module.js" /export/
const PI = 3.14;

export default PI;
```
```javascript filename="main.js" /import/
import PI from './module.js';
console.log(PI); // In ra 3.14
```

> Import/Export được ứng dụng rộng rãi trong các framework như React, Vue, Angular, giúp tổ chức mã nguồn và quản lý phụ thuộc giữa các tệp một cách hiệu quả.

Lợi ích chính:
- Giúp tổ chức code tốt hơn và dễ dàng quản lý hơn.
- Giúp dễ dàng chia sẻ code giữa các tệp và dự án khác nhau.
- Giúp dễ dàng sử dụng lại code mà không cần phải sao chép và dán code.
- Giúp dễ dàng kiểm soát phạm vi (scope) của biến và hàm, tránh xung đột tên biến trong phạm vi toàn cục (global scope).
- Giúp dễ dàng sử dụng các thư viện và module bên ngoài mà không cần phải sử dụng cú pháp phức tạp như trong ES5.

### Promises

Promises là một cách tiếp cận mới trong ES6 để xử lý các tác vụ bất đồng bộ (asynchronous tasks) trong JavaScript. Promises giúp bạn dễ dàng quản lý các tác vụ bất đồng bộ mà không cần phải sử dụng các callback phức tạp.

**Cú pháp:**

```javascript
const promise = new Promise((resolve, reject) => {
    // Thực hiện tác vụ bất đồng bộ
    if (/* thành công */) {
        resolve(value); // Gọi hàm resolve khi tác vụ thành công
    } else {
        reject(error); // Gọi hàm reject khi có lỗi xảy ra
    }
});
```

```javascript
promise
    .then(result => {
        // Xử lý kết quả khi tác vụ thành công
    })
    .catch(error => {
        // Xử lý lỗi khi tác vụ thất bại
    });
```

**Ví dụ:**

```javascript
const fetchData = new Promise((resolve, reject) => {
    setTimeout(() => {
        const data = { name: 'John', age: 30 };
        resolve(data); // Gọi hàm resolve khi dữ liệu đã được tải về
    }, 2000);
});

fetchData
    .then(data => {
        console.log(data); // In ra { name: 'John', age: 30 }
    })
    .catch(error => {
        console.error(error); // Xử lý lỗi nếu có
    });
```

Promise là kết quả trả về của hàm `fetch`

```javascript
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => {
        console.log(data); // In ra dữ liệu từ API
    })
    .catch(error => {
        console.error(error); // Xử lý lỗi nếu có
    });
```

#### Async/Await

Async/Await là một cú pháp mới trong ES6 giúp bạn viết mã bất đồng bộ (asynchronous code) một cách dễ dàng hơn và dễ đọc hơn. Async/Await được xây dựng dựa trên Promises, giúp bạn xử lý các tác vụ bất đồng bộ mà không cần phải sử dụng các callback phức tạp.

```javascript
async function functionName() {
    // Thân hàm
    // await promise
}
```

**Ví dụ:**

```javascript
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data); // In ra dữ liệu từ API
    } catch (error) {
        console.error(error); // Xử lý lỗi nếu có
    }
}

fetchData();
```

<Callout type="error">
`await` chỉ có thể được sử dụng trong các hàm được khai báo với từ khóa `async`. Khi sử dụng `await`, mã sẽ tạm dừng cho đến khi Promise được giải quyết (resolved) hoặc bị từ chối (rejected).
</Callout>

### Object Literals

Object literals trong ES6 cho phép bạn định nghĩa các thuộc tính và phương thức của đối tượng một cách ngắn gọn hơn. Bạn có thể sử dụng cú pháp rút gọn để định nghĩa các thuộc tính và phương thức mà không cần phải sử dụng cú pháp truyền thống.

**Cú pháp:**

```javascript
const objectName = {
    property1,
    property2,
    methodName() {
        // Thân hàm
    }
};
```

**Ví dụ:**

```javascript
const name = 'John';
const age = 30;

const person = {
    name,
    age,
    greet() {
        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
    }
};
person.greet(); // In ra Hello, my name is John and I am 30 years old.
```

Có thể truy xuất thuộc tính của đối tượng bằng cách sử dụng dấu chấm (dot notation) hoặc dấu ngoặc vuông (bracket notation).

```javascript
console.log(person.name); // In ra John

console.log(person['age']); // In ra 30
```
